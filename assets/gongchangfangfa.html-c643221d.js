import{_ as a,o as e,c as t,d as c}from"./app-4023f1b2.js";const o={},i=c('<h1 id="工厂方法" tabindex="-1"><a class="header-anchor" href="#工厂方法" aria-hidden="true">#</a> 工厂方法</h1><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><blockquote><p>我们准备开发一款全能的阅读器，需要支持 txt, markdown, pdf 等各种格式文件的预览，采用工厂方法模式，实现功能。父工厂提供相应的功能接口， 具体的工厂继承该工厂来具体实现功能。</p><p>要点:</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 添加新的格式支持时，不会改动原有工厂和其它的具体实现。</li></ul></blockquote><h2 id="设计思想" tabindex="-1"><a class="header-anchor" href="#设计思想" aria-hidden="true">#</a> 设计思想</h2><blockquote><p>工厂模式的设计思想是将对象的创建过程抽象出来，由工厂类负责创建具体的对象。这样可以将对象的创建与使用分离，降低系统的耦合度，使得系统更加灵活，易于扩展和维护。</p></blockquote><h2 id="在-jdk-和-spring-中的应用案例" tabindex="-1"><a class="header-anchor" href="#在-jdk-和-spring-中的应用案例" aria-hidden="true">#</a> 在 JDK 和 Spring 中的应用案例</h2><blockquote><p>JDK：Collection 系列、Calendar、NumberFormat 等</p></blockquote><blockquote><p>Spring：BeanFactory、MessageSource 等</p></blockquote><h2 id="使用总结" tabindex="-1"><a class="header-anchor" href="#使用总结" aria-hidden="true">#</a> 使用总结</h2><ol><li>使用者不需要关心对象的创建，只需要关注其使用。</li><li>可以实现解耦，各个工厂的实现在各自的工厂中实现。</li><li>实现形式上和Java多态相似。</li></ol>',10),r=[i];function n(l,s){return e(),t("div",null,r)}const h=a(o,[["render",n],["__file","gongchangfangfa.html.vue"]]);export{h as default};
