import{_ as e,o as a,c as r,d as t}from"./app-4023f1b2.js";const n={},i=t('<h1 id="原型模式-prototype-pattern" tabindex="-1"><a class="header-anchor" href="#原型模式-prototype-pattern" aria-hidden="true">#</a> 原型模式(Prototype Pattern)</h1><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式之一。</p><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><p>Java中的实例克隆使用的就是原型模式，在一个已有的实例的基础上创建一个状态相同的实例。</p><h2 id="设计思想" tabindex="-1"><a class="header-anchor" href="#设计思想" aria-hidden="true">#</a> 设计思想</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="在-jdk-和-spring-中的应用案例" tabindex="-1"><a class="header-anchor" href="#在-jdk-和-spring-中的应用案例" aria-hidden="true">#</a> 在 JDK 和 Spring 中的应用案例</h2><blockquote><p>JDK中的clone()方法</p></blockquote><h2 id="使用总结" tabindex="-1"><a class="header-anchor" href="#使用总结" aria-hidden="true">#</a> 使用总结</h2><ol><li>主要解决在运行期建立和删除原型。</li><li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li></ol>',10),o=[i];function h(d,c){return a(),r("div",null,o)}const l=e(n,[["render",h],["__file","yuanxingmoshi.html.vue"]]);export{l as default};
